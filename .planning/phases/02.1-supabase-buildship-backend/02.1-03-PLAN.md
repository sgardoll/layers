# Plan 02.1-03: Flutter Supabase Client

## Objective
Replace REST-based LayerService with Supabase client using direct DB operations + realtime subscriptions.

## Dependencies

```yaml
dependencies:
  supabase_flutter: ^2.0.0
```

## New Architecture

**Old (REST):**
```
Flutter → POST /api/jobs → Backend → fal.ai → Poll GET /api/jobs/:id
```

**New (Supabase):**
```
Flutter → INSERT projects → Supabase webhook → BuildShip → Subscribe to row changes
```

## Implementation

### 1. Supabase Client Setup

`lib/core/supabase_client.dart`:
```dart
final supabaseProvider = Provider<SupabaseClient>((ref) {
  return Supabase.instance.client;
});
```

Initialize in `main.dart`:
```dart
await Supabase.initialize(
  url: 'YOUR_SUPABASE_URL',
  anonKey: 'YOUR_ANON_KEY',
);
```

### 2. Replace LayerService

`lib/services/supabase_layer_service.dart`:

```dart
class SupabaseLayerService {
  final SupabaseClient _client;

  // Create project (triggers layering job)
  Future<Result<String>> createProject({
    required String sourceImagePath,
    Map<String, dynamic>? params,
  }) async {
    final response = await _client
      .from('projects')
      .insert({
        'source_image_path': sourceImagePath,
        'status': 'queued',
        'params': params ?? {},
      })
      .select('id')
      .single();
    return Success(response['id']);
  }

  // Upload source image
  Future<Result<String>> uploadSourceImage(Uint8List bytes, String filename) async {
    final path = 'sources/${DateTime.now().millisecondsSinceEpoch}_$filename';
    await _client.storage
      .from('source-images')
      .uploadBinary(path, bytes);
    return Success(path);
  }

  // Subscribe to project status
  Stream<Project> watchProject(String projectId) {
    return _client
      .from('projects')
      .stream(primaryKey: ['id'])
      .eq('id', projectId)
      .map((rows) => Project.fromJson(rows.first));
  }

  // Fetch layers for project
  Future<Result<List<Layer>>> getProjectLayers(String projectId) async {
    final response = await _client
      .from('project_layers')
      .select()
      .eq('project_id', projectId)
      .order('z_index');
    return Success(response.map((r) => Layer.fromJson(r)).toList());
  }

  // Create export (triggers export builder)
  Future<Result<String>> createExport({
    required String projectId,
    required String type,
    List<String>? layerIds,
  }) async {
    final response = await _client
      .from('exports')
      .insert({
        'project_id': projectId,
        'type': type,
        'status': 'queued',
        'options': layerIds != null ? {'layerIds': layerIds} : {},
      })
      .select('id')
      .single();
    return Success(response['id']);
  }

  // Watch export status
  Stream<Export> watchExport(String exportId) {
    return _client
      .from('exports')
      .stream(primaryKey: ['id'])
      .eq('id', exportId)
      .map((rows) => Export.fromJson(rows.first));
  }
}
```

### 3. Update JobNotifier → ProjectNotifier

Replace polling with realtime subscription:

```dart
class ProjectNotifier extends StateNotifier<ProjectState> {
  StreamSubscription? _subscription;

  Future<void> startProject(Uint8List imageBytes, String filename) async {
    state = ProjectState.uploading();
    
    // Upload image
    final pathResult = await _service.uploadSourceImage(imageBytes, filename);
    if (pathResult is Failure) {
      state = ProjectState.error(pathResult.error);
      return;
    }
    
    // Create project (triggers BuildShip workflow)
    final projectResult = await _service.createProject(
      sourceImagePath: (pathResult as Success).value,
    );
    if (projectResult is Failure) {
      state = ProjectState.error(projectResult.error);
      return;
    }
    
    final projectId = (projectResult as Success).value;
    state = ProjectState.processing(projectId);
    
    // Subscribe to status changes
    _subscription = _service.watchProject(projectId).listen((project) {
      switch (project.status) {
        case 'processing':
        case 'packaging':
          state = ProjectState.processing(projectId);
        case 'ready':
          state = ProjectState.ready(projectId);
          _subscription?.cancel();
        case 'failed':
          state = ProjectState.error(project.errorMessage ?? 'Unknown error');
          _subscription?.cancel();
      }
    });
  }
}
```

### 4. Update Models

Update `Project` model to match Supabase schema:
- Add `sourceImagePath`, `sourceImageUrl`
- Add `manifestPath`
- Change status enum to match DB values

Update `Layer` model:
- `pngPath` instead of `pngUrl` as primary
- Add `pngUrl` for signed URL

### 5. Environment Config

`lib/core/env.dart`:
```dart
abstract class Env {
  static const supabaseUrl = String.fromEnvironment('SUPABASE_URL');
  static const supabaseAnonKey = String.fromEnvironment('SUPABASE_ANON_KEY');
}
```

Build with:
```bash
flutter run --dart-define=SUPABASE_URL=... --dart-define=SUPABASE_ANON_KEY=...
```

## Tasks

- [ ] Add supabase_flutter dependency
- [ ] Create Supabase client provider
- [ ] Implement SupabaseLayerService
- [ ] Replace JobNotifier with ProjectNotifier (realtime)
- [ ] Update models to match Supabase schema
- [ ] Update ExportService to use Supabase
- [ ] Remove old backend/ directory (or archive)
- [ ] Test end-to-end flow

## Verification

- [ ] Upload image → project created in Supabase
- [ ] Project status updates via realtime subscription
- [ ] Layers fetched correctly after processing
- [ ] Export creation triggers BuildShip workflow
- [ ] Export download works via signed URL

## Migration Notes

The old `backend/` directory with Dart Shelf server is now deprecated.
Keep for reference but it will be replaced by:
- Supabase (database + storage + realtime)
- BuildShip (serverless workflows)
