---
phase: 20-per-export-pricing
plan: 05
type: execute
wave: 3
depends_on: ["20-03", "20-02"]
files_modified: [
  "lib/screens/purchase_credit_screen.dart",
  "lib/widgets/purchase_button.dart"
]
autonomous: false
domain: flutter
---

<objective>
Create purchase flow UI for consumable export credits and integrate with existing paywall.

Purpose: Enable users to purchase single export credits with clear pricing and restore functionality.
Output: Purchase credit screen, reusable purchase button, integration with existing paywall and export flow.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
@~/.config/opencode/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@lib/screens/paywall_screen.dart
@lib/services/revenuecat_service.dart
@lib/providers/credits_provider.dart
@lib/providers/entitlement_provider.dart

**Requirements from ROADMAP:**
- MON-01: User can purchase single export credit for $0.50
- MON-04: Clear price display with configure-before-pay flow
- MON-05: Restore purchases works for both subscriptions and consumables
- MON-06: Test consumable repurchase on Android (known platform issue)

**Key decisions from STATE.md:**
- Design system uses Inter font via Google Fonts
- Dual theme system: Light (clean/airy) and Dark (immersive navy)
- RevenueCat already integrated with logIn/logOut linking

**Existing patterns (from paywall_screen.dart):**
- ConsumerStatefulWidget with Riverpod
- Offerings/Package loading with loading states
- Purchase with _purchasePackage() pattern
- Restore purchases functionality
- Legal links (Terms, Privacy) in RichText
- Error states with retry

**Service methods available:**
- RevenueCatService.getExportPackage() - returns Package? for export credit
- RevenueCatService.purchaseExportCredit() - handles consumable purchase
- CreditsProvider.addCredits() - adds credits after successful purchase
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PurchaseButton widget</name>
  <files>lib/widgets/purchase_button.dart</files>
  <action>
Create reusable PurchaseButton widget for initiating credit purchases:

Widget features:
- Displays price (e.g., "$0.50") with clear styling
- Loading state during purchase
- Success/error state handling
- Disabled state when already processing

Constructor:
```dart
const PurchaseButton({
  super.key,
  required this.price,
  required this.onPressed,
  this.isLoading = false,
  this.isEnabled = true,
  this.label = 'Buy Credit',
});
```

Design:
- Primary filled button with accent color
- Price displayed prominently
- Loading indicator replaces text during purchase
- Error state with retry option

Use this in both PurchaseCreditScreen and ExportBottomSheet (when credits = 0).
  </action>
  <verify>Widget renders with all states (normal, loading, disabled)</verify>
  <done>Reusable purchase button with price display and state management</done>
</task>

<task type="auto">
  <name>Task 2: Create PurchaseCreditScreen</name>
  <files>lib/screens/purchase_credit_screen.dart</files>
  <action>
Create PurchaseCreditScreen for buying export credits:

**Structure:**
Scaffold with AppBar "Buy Export Credit"

**Content sections:**
1. Header with credit icon and title
2. Explanation text: "Get 1 export credit for a one-time layer export"
3. Price display: "$0.50 per credit" with platform note
4. PurchaseButton (from Task 1) - primary CTA
5. Bundle option (future): "Or subscribe for unlimited exports"
6. Restore purchases button
7. Legal links (Terms, Privacy) - reuse from paywall_screen.dart

**Purchase flow:**
```dart
Future<void> _purchaseCredit() async {
  setState(() => _isLoading = true);
  
  final revenueCat = ref.read(revenueCatServiceProvider);
  final package = await revenueCat.getExportPackage();
  
  if (package == null) {
    showError('Export credits not available');
    return;
  }
  
  final result = await revenueCat.purchaseExportCredit(package);
  
  if (result.isSuccess) {
    // Add credits to user's balance
    await ref.read(creditsProvider.notifier).addCredits(
      amount: 1,
      type: CreditTransactionType.purchase,
      description: 'Purchased: ${package.storeProduct.priceString}',
    );
    
    if (mounted) {
      Navigator.of(context).pop(true); // Return success
    }
  } else if (result.isCancelled) {
    // User cancelled, no error
  } else {
    showError(result.errorMessage ?? 'Purchase failed');
  }
  
  setState(() => _isLoading = false);
}
```

**Restore flow:**
Similar to paywall_screen.dart - call restorePurchases(), sync any restored consumables to credits.

**Props:**
```dart
static Future<bool> show(BuildContext context) async {
  return await showModalBottomSheet<bool>(...) ?? false;
}
```

Follow existing paywall_screen.dart patterns for consistency.
  </action>
  <verify>Screen opens, loads product, handles purchase flow</verify>
  <done>Purchase credit screen with full purchase/restore flow</done>
</task>

<task type="auto">
  <name>Task 3: Integrate with ExportBottomSheet</name>
  <files>lib/screens/export_bottom_sheet.dart</files>
  <action>
Update ExportBottomSheet (from Plan 04) to integrate PurchaseCreditScreen:

When user taps "Export" with 0 credits:
```dart
void _onExportPressed() async {
  final hasCredits = ref.read(hasCreditsProvider);
  
  if (!hasCredits) {
    // Navigate to purchase screen
    final purchased = await PurchaseCreditScreen.show(context);
    if (!purchased) return; // User cancelled or purchase failed
    
    // Credits should now be available via realtime update
    // Wait a moment for provider to update, or force refresh
    await ref.read(creditsProvider.notifier).refresh();
  }
  
  // Continue with credit consumption...
}
```

Update the button text:
- If has credits: "Export (1 credit)"
- If no credits: "Buy Credit ($0.50)"

Ensure smooth UX: don't close bottom sheet on purchase success, just update state.
  </action>
  <verify>Export flow triggers purchase when credits = 0, continues after purchase</verify>
  <done>Purchase flow integrated into export bottom sheet</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Export credit purchase flow</what-built>
  <how-to-verify>
Test the complete purchase flow:

1. Open app and ensure you have 0 credits
2. Navigate to a project with layers
3. Tap Export button to open ExportBottomSheet
4. Verify "Buy Credit ($0.50)" button shows (instead of "Export")
5. Tap to open PurchaseCreditScreen
6. Verify price displays correctly ($0.50)
7. Attempt purchase (use sandbox/test card):
   - Success: Credit should be added, return to export
   - Cancel: Should return without error
   - Error: Should show error message

Android specific test:
- Purchase credit
- Try to purchase again immediately
- Verify consumable can be repurchased (Android test quirk - consumables don't consume in test)
  </how-to-verify>
  <resume-signal>Type "approved" if purchase flow works, or describe issues</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] PurchaseButton widget created with all states
- [ ] PurchaseCreditScreen follows paywall_screen.dart patterns
- [ ] Price displays clearly ($0.50)
- [ ] Purchase flow handles success/cancel/error
- [ ] Restore purchases works for consumables
- [ ] ExportBottomSheet integrates purchase flow
- [ ] Credits added to balance after successful purchase
- [ ] Legal links (Terms, Privacy) included
</verification>

<success_criteria>

- PurchaseButton reusable widget with price display
- PurchaseCreditScreen with clear pricing and purchase flow
- Restore purchases works for consumables
- Export flow triggers purchase when credits = 0
- Credits added to balance after successful purchase
- Legal compliance (Terms, Privacy links)
- Android consumable repurchase handling
  </success_criteria>

<output>
After completion, create `.planning/phases/20-per-export-pricing/20-05-SUMMARY.md`
</output>
