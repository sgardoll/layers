---
phase: 20-per-export-pricing
plan: 03
type: execute
wave: 2
depends_on: ["20-01"]
files_modified: [
  "lib/providers/credits_provider.dart",
  "lib/models/credit_transaction.dart",
  "lib/services/credits_service.dart"
]
autonomous: true
domain: flutter
---

<objective>
Build CreditsProvider for managing export credit balance with realtime updates from Supabase.

Purpose: Enable credit balance tracking and consumption for per-export pricing model.
Output: CreditsProvider following existing entitlement_provider.dart pattern, CreditsService for Supabase operations, CreditTransaction model.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@lib/providers/entitlement_provider.dart
@lib/services/revenuecat_service.dart
@lib/models/project.dart

**Requirements from ROADMAP:**
- DB-01: user_credits table with credits_remaining, monthly_bonus_credits
- STATE-01: CreditsProvider following entitlement_provider.dart pattern
- STATE-03: Realtime subscription for credit updates

**Patterns to follow (from entitlement_provider.dart):**
- StateNotifier with immutable state class
- Riverpod StateNotifierProvider with dependencies declared
- Constructor init pattern with _setupListener()
- Loading/error state management
- copyWith pattern for state updates
- User change handling via Provider dependencies

**Database schema (from 20-01):**
- user_credits table: user_id, credits_remaining, monthly_bonus_credits, last_bonus_date
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CreditTransaction model</name>
  <files>lib/models/credit_transaction.dart</files>
  <action>
Create CreditTransaction model class with:

Fields:
- id (String) - transaction UUID
- userId (String) - user UUID
- type (CreditTransactionType enum) - purchase, consumption, bonus, refund
- amount (int) - positive for credits added, negative for consumed
- balanceAfter (int) - credits_remaining after this transaction
- description (String?) - human-readable description
- metadata (Map<String, dynamic>?) - extra data (project_id, export_id, etc.)
- createdAt (DateTime)

Enum CreditTransactionType { purchase, consumption, monthlyBonus, refund }

Factory methods:
- fromJson(Map<String, dynamic> json) - parse from Supabase
- toJson() - serialize for Supabase

Similar pattern to lib/models/project.dart and lib/models/layer.dart.
  </action>
  <verify>dart analyze shows no errors in new file</verify>
  <done>Model class created with all fields, enum, and serialization methods</done>
</task>

<task type="auto">
  <name>Task 2: Create CreditsService</name>
  <files>lib/services/credits_service.dart</files>
  <action>
Create CreditsService class for Supabase operations:

Methods:
- getUserCredits(String userId) -> Future<UserCredits?>
  Query user_credits table for user's current balance
  
- consumeCredit(String userId, {String? projectId, String? description})
  Atomic operation: decrement credits_remaining by 1, insert transaction record
  Use Supabase RPC if available, otherwise transaction with proper error handling
  Return success/failure with new balance
  
- addCredits(String userId, int amount, CreditTransactionType type, {String? description, Map? metadata})
  Add credits (for purchases or bonuses)
  Update user_credits.credits_remaining, insert transaction record
  
- getTransactionHistory(String userId, {int limit = 50})
  Fetch recent credit_transactions for user
  
- subscribeToCreditChanges(String userId, Function callback)
  Set up Supabase realtime subscription on user_credits table
  Return subscription object for cleanup

UserCredits model (inner class or separate):
- userId, creditsRemaining, monthlyBonusCredits, lastBonusDate, updatedAt

Follow patterns from lib/services/revenuecat_service.dart for error handling and debug logging.
  </action>
  <verify>dart analyze shows no errors; all methods have proper signatures</verify>
  <done>Service class created with all CRUD operations and realtime subscription support</done>
</task>

<task type="auto">
  <name>Task 3: Create CreditsProvider</name>
  <files>lib/providers/credits_provider.dart</files>
  <action>
Create CreditsProvider following lib/providers/entitlement_provider.dart pattern exactly:

**CreditState class:**
- creditsRemaining (int, default 0)
- monthlyBonusCredits (int, default 0)
- totalExports (int, default 0) - track lifetime exports for stats
- isLoading (bool, default true)
- errorMessage (String?)
- copyWith method

**StateNotifierProvider:**
```dart
final creditsProvider = StateNotifierProvider<CreditsNotifier, CreditState>((ref) {
  final creditsService = ref.watch(creditsServiceProvider);
  final user = ref.watch(currentUserProvider);
  return CreditsNotifier(
    creditsService: creditsService,
    userId: user?.id,
  );
}, dependencies: [creditsServiceProvider, currentUserProvider]);
```

**CreditsNotifier extends StateNotifier<CreditState>:**
- Constructor: takes creditsService and userId, calls _init(userId)
- _init(): load credits, setup realtime listener
- _setupRealtimeListener(): subscribe to Supabase realtime on user_credits
- loadCredits(): fetch from service, update state
- consumeCredit(): call service, optimistically update state, handle errors with rollback
- refresh(): reload credits from server

**Derived providers:**
- hasCreditsProvider: bool - creditsRemaining > 0
- creditsRemainingProvider: int - current balance

Include proper cleanup in dispose() for realtime subscription.
  </action>
  <verify>dart analyze shows no errors; follows entitlement_provider patterns</verify>
  <done>Provider created with state management, realtime updates, and derived providers</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] dart analyze passes on all new files
- [ ] CreditTransaction model has fromJson/toJson
- [ ] CreditsService has all required methods (get, consume, add, history, subscribe)
- [ ] CreditsProvider follows entitlement_provider.dart patterns
- [ ] Realtime subscription setup and cleanup implemented
- [ ] Derived providers (hasCredits, creditsRemaining) exposed
- [ ] Error handling with proper state rollback on consume failure
</verification>

<success_criteria>

- CreditTransaction model created with serialization
- CreditsService handles all Supabase operations atomically
- CreditsProvider follows established Riverpod patterns
- Realtime subscription updates credit balance automatically
- Credit consumption with optimistic UI and rollback on error
- Derived providers for common queries (hasCredits, creditsRemaining)
  </success_criteria>

<output>
After completion, create `.planning/phases/20-per-export-pricing/20-03-SUMMARY.md`
</output>
