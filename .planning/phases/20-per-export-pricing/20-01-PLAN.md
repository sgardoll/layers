---
phase: 20-per-export-pricing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [
  "supabase/migrations/20260207_add_user_credits.sql",
  "supabase/migrations/20260207_add_purchase_transactions.sql",
  "supabase/migrations/20260207_fix_projects_fk.sql"
]
autonomous: true
domain: flutter
---

<objective>
Create database schema for export credit system including user credits tracking and purchase transaction idempotency.

Purpose: Enable per-export consumable IAP by storing credit balances and purchase history with proper RLS security.
Output: Three migration files creating user_credits table, purchase_transactions table, and fixing projects FK cascade.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@supabase/migrations/20260124_add_rls_policies.sql
@lib/models/project.dart

**Requirements from ROADMAP:**
- DB-01: Create user_credits table (user_id, credits_remaining, monthly_bonus_credits, last_bonus_date)
- DB-02: Create purchase_transactions table (transaction_id, user_id, product_id, amount, status, verified_at)
- DB-04: Fix projects.user_id FK from SET NULL to CASCADE

**Patterns from existing migrations:**
- Use idempotent DROP POLICY IF EXISTS / CREATE POLICY pattern
- Enable RLS with ALTER TABLE ... ENABLE ROW LEVEL SECURITY
- Use auth.uid() for user-scoped policies
- Set updated_at trigger if updating tables
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create user_credits table migration</name>
  <files>supabase/migrations/20260207_add_user_credits.sql</files>
  <action>
Create migration for user_credits table with columns:
- user_id (uuid, PK, references auth.users)
- credits_remaining (integer, default 0, not null)
- monthly_bonus_credits (integer, default 0) - for Pro subscriber monthly bonus
- last_bonus_date (timestamptz) - track when monthly bonus was granted
- created_at (timestamptz, default now())
- updated_at (timestamptz, default now())

Enable RLS. Create policies:
- Users can view own credits: SELECT WHERE auth.uid() = user_id
- Users can update own credits: UPDATE WHERE auth.uid() = user_id (for consumption)
- Service role can insert/update all (for RevenueCat webhook)

Include trigger to auto-update updated_at on row modification.
  </action>
  <verify>File exists with valid SQL syntax</verify>
  <done>Migration file created with proper schema, RLS policies, and trigger</done>
</task>

<task type="auto">
  <name>Task 2: Create purchase_transactions table migration</name>
  <files>supabase/migrations/20260207_add_purchase_transactions.sql</files>
  <action>
Create migration for purchase_transactions table for idempotency:
- id (uuid, PK, default gen_random_uuid())
- transaction_id (text, unique, not null) - RevenueCat transaction ID
- user_id (uuid, references auth.users)
- product_id (text, not null) - RevenueCat product identifier
- amount (integer) - number of credits purchased
- price_cents (integer) - price paid in cents
- currency (text, 3 chars) - ISO currency code
- status (text) - 'pending', 'completed', 'failed', 'refunded'
- revenuecat_json (jsonb) - full RevenueCat payload for debugging
- verified_at (timestamptz) - when transaction was verified
- created_at (timestamptz, default now())

Enable RLS. Create policies:
- Users can view own transactions: SELECT WHERE auth.uid() = user_id
- Service role can insert/update all (for RevenueCat webhook)
- Prevent users from modifying transactions directly (insert/update denied for non-service)
  </action>
  <verify>File exists with valid SQL syntax</verify>
  <done>Migration file created with idempotency tracking and proper RLS</done>
</task>

<task type="auto">
  <name>Task 3: Fix projects.user_id FK cascade</name>
  <files>supabase/migrations/20260207_fix_projects_fk.sql</files>
  <action>
Create migration to fix projects.user_id foreign key:
- Drop existing FK constraint if exists
- Add new FK with ON DELETE CASCADE (currently SET NULL)
- This ensures projects are deleted when user account is deleted

Check existing constraint name first with:
SELECT conname FROM pg_constraint WHERE conrelid = 'projects'::regclass AND contype = 'f';

Then:
ALTER TABLE projects DROP CONSTRAINT IF EXISTS [constraint_name];
ALTER TABLE projects ADD CONSTRAINT projects_user_id_fkey 
  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;
  </action>
  <verify>File exists with valid SQL syntax</verify>
  <done>Migration file created fixing FK from SET NULL to CASCADE</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All three migration files exist in supabase/migrations/
- [ ] SQL syntax is valid (check for missing semicolons, proper quotes)
- [ ] RLS policies follow existing patterns from 20260124 migration
- [ ] user_credits has all required columns per DB-01
- [ ] purchase_transactions has transaction_id unique constraint per DB-02
- [ ] projects FK migration properly references auth.users with CASCADE
</verification>

<success_criteria>

- All three migration files created with correct schema
- user_credits table ready for CreditsProvider integration
- purchase_transactions table ready for idempotency tracking
- projects FK fixed for proper cascade deletion
- RLS policies secure user data while allowing service access
  </success_criteria>

<output>
After completion, create `.planning/phases/20-per-export-pricing/20-01-SUMMARY.md`
</output>
