---
phase: 21-settings-enhancement
plan: 03
type: execute
depends_on: ["21-02"]
files_modified: [
  "supabase/functions/delete-user-account/index.ts"
]
autonomous: true
domain: supabase
---

<objective>
Create delete-user-account Edge Function for secure cascade deletion of all user data.

Purpose: Enable complete account deletion with proper data cleanup including projects, layers, exports, and storage files.
Output: Edge Function that securely deletes all user data in correct order.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@supabase/functions/

**Requirements from ROADMAP:**
- SET-05: "Delete Account" option with confirmation flow
- SET-06: Account deletion performs full data cleanup
- DB-03: Delete user account Edge Function with cascade cleanup

**Key implementation notes from ROADMAP:**
- Create `delete_user_account` Edge Function (not RPC) for secure cascade deletion
- Storage cleanup must happen BEFORE auth user deletion (not CASCADE)
- Always call `RevenueCat.logOut()` before account deletion
- Use `security definer` with `auth.uid()` validation
- Test deletion end-to-end with orphaned data verification

**State context:**
- Fix missing `delete_user_account` RPC function in Supabase (see .planning/todos/pending/)
- This plan addresses that pending todo

**Deletion order (critical):**
1. Delete storage files (exports, layer images)
2. Delete database records (exports, layers, projects, user_credits)
3. Delete auth user
4. Cleanup any orphaned data

**Security requirements:**
- Must verify requesting user matches auth.uid()
- Must not allow deleting other users' data
- Must log deletion for audit purposes
- Must be idempotent (safe to retry)
</context>

<tasks>

<task type="auto">
  <name>Create delete-user-account Edge Function</name>
  <files>supabase/functions/delete-user-account/index.ts</files>
  <action>
Create Edge Function for secure account deletion:

**File:** `supabase/functions/delete-user-account/index.ts`

```typescript
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  // Handle CORS
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    // Create Supabase client with auth context
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: req.headers.get('Authorization')! },
        },
      }
    )

    // Get current user
    const {
      data: { user },
      error: userError,
    } = await supabaseClient.auth.getUser()

    if (userError || !user) {
      return new Response(
        JSON.stringify({ error: 'Unauthorized' }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    const userId = user.id

    // Start deletion process
    console.log(`Starting account deletion for user: ${userId}`)

    // 1. Get all projects for this user (need these to delete storage files)
    const { data: projects, error: projectsError } = await supabaseClient
      .from('projects')
      .select('id, thumbnail_path')
      .eq('user_id', userId)

    if (projectsError) {
      console.error('Error fetching projects:', projectsError)
      throw projectsError
    }

    const projectIds = projects?.map(p => p.id) ?? []

    // 2. Get all exports for this user
    const { data: exports, error: exportsError } = await supabaseClient
      .from('exports')
      .select('id, file_path')
      .eq('user_id', userId)

    if (exportsError) {
      console.error('Error fetching exports:', exportsError)
      throw exportsError
    }

    // 3. Get all layers for user's projects
    const { data: layers, error: layersError } = await supabaseClient
      .from('layers')
      .select('id, image_path, mask_path')
      .in('project_id', projectIds)

    if (layersError) {
      console.error('Error fetching layers:', layersError)
      throw layersError
    }

    // 4. Delete storage files (must happen before DB records)
    const storageFiles: string[] = []
    
    // Collect export files
    exports?.forEach(exp => {
      if (exp.file_path) storageFiles.push(exp.file_path)
    })
    
    // Collect layer files
    layers?.forEach(layer => {
      if (layer.image_path) storageFiles.push(layer.image_path)
      if (layer.mask_path) storageFiles.push(layer.mask_path)
    })
    
    // Collect project thumbnails
    projects?.forEach(proj => {
      if (proj.thumbnail_path) storageFiles.push(proj.thumbnail_path)
    })

    console.log(`Deleting ${storageFiles.length} storage files`)

    // Delete files from storage (ignore errors - files may not exist)
    for (const filePath of storageFiles) {
      try {
        await supabaseClient.storage
          .from('exports')
          .remove([filePath])
      } catch (e) {
        console.log(`File may not exist: ${filePath}`)
      }
    }

    // 5. Delete database records in reverse dependency order
    
    // Delete exports
    if (exports?.length > 0) {
      const { error: deleteExportsError } = await supabaseClient
        .from('exports')
        .delete()
        .eq('user_id', userId)
      
      if (deleteExportsError) {
        console.error('Error deleting exports:', deleteExportsError)
        throw deleteExportsError
      }
      console.log(`Deleted ${exports.length} exports`)
    }

    // Delete layers (for user's projects)
    if (layers?.length > 0) {
      const { error: deleteLayersError } = await supabaseClient
        .from('layers')
        .delete()
        .in('project_id', projectIds)
      
      if (deleteLayersError) {
        console.error('Error deleting layers:', deleteLayersError)
        throw deleteLayersError
      }
      console.log(`Deleted ${layers.length} layers`)
    }

    // Delete projects
    if (projects?.length > 0) {
      const { error: deleteProjectsError } = await supabaseClient
        .from('projects')
        .delete()
        .eq('user_id', userId)
      
      if (deleteProjectsError) {
        console.error('Error deleting projects:', deleteProjectsError)
        throw deleteProjectsError
      }
      console.log(`Deleted ${projects.length} projects`)
    }

    // Delete user credits
    const { error: deleteCreditsError } = await supabaseClient
      .from('user_credits')
      .delete()
      .eq('user_id', userId)
    
    if (deleteCreditsError) {
      console.error('Error deleting credits:', deleteCreditsError)
      // Non-critical, continue
    }

    // Delete purchase transactions
    const { error: deleteTransactionsError } = await supabaseClient
      .from('purchase_transactions')
      .delete()
      .eq('user_id', userId)
    
    if (deleteTransactionsError) {
      console.error('Error deleting transactions:', deleteTransactionsError)
      // Non-critical, continue
    }

    // 6. Finally, delete the auth user
    // Note: This requires service_role key or admin privileges
    // We'll call this from the client side after this function succeeds
    
    console.log(`Account data deletion complete for user: ${userId}`)

    return new Response(
      JSON.stringify({
        success: true,
        message: 'User data deleted successfully',
        deleted: {
          projects: projects?.length ?? 0,
          exports: exports?.length ?? 0,
          layers: layers?.length ?? 0,
          storageFiles: storageFiles.length,
        }
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )

  } catch (error) {
    console.error('Account deletion error:', error)
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )
  }
})
```

**Deploy the function:**
```bash
supabase functions deploy delete-user-account
```

**Configuration:**
- Function should run with authenticated user context
- No additional secrets needed (uses anon key for auth)
- Logs all deletion operations for audit trail
  </action>
  <verify>Function deploys without errors</verify>
  <done>Delete user account Edge Function created and deployed</done>
</task>

<task type="auto">
  <name>Create Dart service wrapper</name>
  <files>lib/services/account_service.dart</files>
  <action>
Create a Dart service to call the Edge Function:

```dart
class AccountService {
  final SupabaseClient _client;
  
  AccountService(this._client);
  
  /// Delete all user data
  /// Returns true if successful
  Future<bool> deleteUserData() async {
    try {
      final response = await _client.functions.invoke(
        'delete-user-account',
        method: HttpMethod.post,
      );
      
      if (response.status != 200) {
        throw Exception('Failed to delete account: ${response.data}');
      }
      
      final result = response.data as Map<String, dynamic>;
      
      if (result['success'] != true) {
        throw Exception(result['error'] ?? 'Unknown error');
      }
      
      return true;
    } catch (e) {
      throw Exception('Account deletion failed: $e');
    }
  }
  
  /// Delete auth user (must be called after data deletion)
  Future<void> deleteAuthUser() async {
    // This requires admin privileges or user must call from client
    // For security, user must be authenticated
    await _client.auth.admin.deleteUser(
      _client.auth.currentUser!.id,
    );
  }
}
```
  </action>
  <verify>Service can invoke Edge Function</verify>
  <done>Dart service wrapper for Edge Function</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Edge Function created and deployed
- [ ] Function authenticates requesting user
- [ ] Deletes storage files before DB records
- [ ] Deletes exports → layers → projects in order
- [ ] Deletes user_credits and purchase_transactions
- [ ] Returns success with deletion counts
- [ ] Dart service can invoke function
- [ ] Error handling for all failure cases
</verification>

<success_criteria>
- delete-user-account Edge Function deployed
- Proper authentication and authorization
- Correct deletion order (storage → DB → auth)
- All user data types cleaned up
- Audit logging
- Dart service wrapper for Flutter integration
</success_criteria>

<output>
After completion, create `.planning/phases/21-settings-enhancement/21-03-SUMMARY.md`
</output>
