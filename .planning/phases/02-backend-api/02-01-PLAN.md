# Plan 02-01: Backend Service + fal.ai Integration

## Goal
Create a lightweight backend that wraps fal.ai's Qwen-Image-Layered API, handles job queuing, and serves layer results to the Flutter client.

## Research Summary

**Model**: `fal-ai/qwen-image-layered` on fal.ai
- Cost: ~$0.05/image
- Latency: 15-30s processing
- Input: `image_url` + `num_inference_steps` (28) + `guidance_scale` (5)
- Output: 1-10 RGBA PNG layers with transparency
- API: Queue-based async with webhooks or polling

**Decision**: Use fal.ai directly (no self-hosting for MVP)
- Simplest integration path
- Pay-per-use scales with demand
- Can migrate to self-hosted Modal/RunPod later if cost becomes issue

## Architecture

```
Flutter App → Our Backend API → fal.ai
     ↑              ↓
     └── poll/webhook ←┘
```

**Backend Stack**: 
- Dart Shelf server (keep same language as Flutter)
- SQLite for job tracking (simple, no external DB)
- Deployed to Fly.io or Railway

## Tasks

### 1. Backend Project Setup
- [ ] Create `backend/` directory in repo
- [ ] Initialize Dart project with shelf, shelf_router
- [ ] Add dependencies: fal_client (or http for raw API), sqlite3
- [ ] Create folder structure: `lib/`, `bin/server.dart`

### 2. fal.ai Integration Service
- [ ] Create `lib/services/fal_service.dart`
- [ ] Implement `submitJob(imageUrl)` → returns fal request_id
- [ ] Implement `checkStatus(requestId)` → returns status + layers
- [ ] Handle fal.ai response parsing (layer URLs, metadata)
- [ ] Add retry logic for transient failures

### 3. Job Queue & Storage
- [ ] Create `lib/models/job.dart` - Job model (id, status, image_url, layers, created_at, expires_at)
- [ ] Create `lib/services/job_store.dart` - SQLite operations
- [ ] Implement job lifecycle: pending → processing → completed/failed
- [ ] Add 24h expiry cleanup (cron or lazy deletion)

### 4. API Routes
- [ ] POST `/api/jobs` - Submit new layering job (accepts image URL or base64)
- [ ] GET `/api/jobs/:id` - Get job status and results
- [ ] GET `/api/jobs/:id/layers` - Get layer URLs (after completion)
- [ ] DELETE `/api/jobs/:id` - Cancel/delete job

### 5. Image Upload Handling
- [ ] POST `/api/upload` - Accept image upload, return temporary URL
- [ ] Store uploads in `/tmp` or cloud storage (S3/R2 for production)
- [ ] Generate signed URLs for fal.ai to access

### 6. Configuration & Deployment
- [ ] Environment variables: FAL_API_KEY, PORT, DATABASE_PATH
- [ ] Create Dockerfile for deployment
- [ ] Add fly.toml or railway.json config
- [ ] Document deployment steps

## API Contract

```yaml
POST /api/jobs
  Request: { "image_url": "https://..." } or { "image_base64": "..." }
  Response: { "job_id": "uuid", "status": "pending" }

GET /api/jobs/:id
  Response: {
    "job_id": "uuid",
    "status": "pending|processing|completed|failed",
    "progress": 0.0-1.0,
    "layers": [...] | null,
    "error": "..." | null,
    "created_at": "ISO8601",
    "expires_at": "ISO8601"
  }

Layer object:
  {
    "id": "layer_0",
    "url": "https://...",
    "width": 1024,
    "height": 768,
    "order": 0
  }
```

## Verification
- [ ] Can submit job and receive job_id
- [ ] Can poll job status until completion
- [ ] Completed job returns layer URLs that are accessible
- [ ] Failed jobs return meaningful error messages
- [ ] Jobs expire after 24h

## Files to Create
- `backend/pubspec.yaml`
- `backend/bin/server.dart`
- `backend/lib/services/fal_service.dart`
- `backend/lib/services/job_store.dart`
- `backend/lib/models/job.dart`
- `backend/lib/routes/jobs_routes.dart`
- `backend/lib/routes/upload_routes.dart`
- `backend/Dockerfile`
- `backend/.env.example`
